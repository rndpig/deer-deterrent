# =============================================================================
# Coordinator Dockerfile - Ring Webhook Handler & Irrigation Controller
# =============================================================================
# This container coordinates between Ring camera events, ML detection,
# and Rainbird irrigation activation
# =============================================================================

FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    curl \
    ffmpeg \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
RUN pip install --no-cache-dir \
    fastapi==0.115.0 \
    uvicorn[standard]==0.32.0 \
    httpx==0.27.2 \
    paho-mqtt==2.1.0 \
    python-multipart==0.0.17 \
    pyyaml==6.0.2 \
    python-dateutil==2.9.0

# Create directories
RUN mkdir -p /app/logs /app/snapshots /app/config

# Create the coordinator service
RUN cat > /app/coordinator_service.py << 'EOF'
#!/usr/bin/env python3
"""
Coordinator Service - Ring Camera → ML Detection → Irrigation Activation
Handles the complete flow from camera event to deterrent action
"""

import os
import logging
import json
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional, Dict, Any
import asyncio
import queue
import threading

from fastapi import FastAPI, Request, BackgroundTasks, HTTPException
from fastapi.responses import JSONResponse
import httpx
import paho.mqtt.client as mqtt

# Configure logging
logging.basicConfig(
    level=os.getenv("LOG_LEVEL", "INFO"),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/app/logs/coordinator.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title="Deer Deterrent Coordinator",
    description="Coordinates Ring cameras, ML detection, and irrigation activation",
    version="1.0.0"
)

# Configuration
CONFIG = {
    "ML_DETECTOR_URL": os.getenv("ML_DETECTOR_URL", "http://ml-detector:8001"),
    "BACKEND_API_URL": os.getenv("BACKEND_API_URL", "http://backend:8000"),
    "MQTT_HOST": os.getenv("MQTT_HOST", "mosquitto"),
    "MQTT_PORT": int(os.getenv("MQTT_PORT", "1883")),
    "MQTT_USER": os.getenv("MQTT_USER", ""),
    "MQTT_PASSWORD": os.getenv("MQTT_PASSWORD", ""),
    "RAINBIRD_IP": os.getenv("RAINBIRD_IP", ""),
    "RAINBIRD_PASSWORD": os.getenv("RAINBIRD_PASSWORD", ""),
    "RAINBIRD_ZONE": os.getenv("RAINBIRD_ZONE", "1"),
    "RAINBIRD_DURATION_SECONDS": int(os.getenv("RAINBIRD_DURATION_SECONDS", "30")),
    "CONFIDENCE_THRESHOLD": float(os.getenv("CONFIDENCE_THRESHOLD", "0.75")),
    "COOLDOWN_SECONDS": int(os.getenv("COOLDOWN_SECONDS", "300")),
    "ENABLE_IRRIGATION": os.getenv("ENABLE_IRRIGATION", "true").lower() == "true",
    "ACTIVE_HOURS_START": int(os.getenv("ACTIVE_HOURS_START", "0")),
    "ACTIVE_HOURS_END": int(os.getenv("ACTIVE_HOURS_END", "24")),
}

# State tracking
last_activation_time: Optional[datetime] = None
mqtt_client: Optional[mqtt.Client] = None
event_queue: queue.Queue = queue.Queue()  # Thread-safe queue for MQTT events
camera_snapshots: Dict[str, bytes] = {}  # Store latest snapshot for each camera


def is_active_hours() -> bool:
    """Check if current time is within active hours"""
    current_hour = datetime.now().hour
    start = CONFIG["ACTIVE_HOURS_START"]
    end = CONFIG["ACTIVE_HOURS_END"]
    
    if start <= end:
        return start <= current_hour < end
    else:  # Wraps midnight
        return current_hour >= start or current_hour < end


async def download_snapshot(url: str) -> bytes:
    """Download image from URL"""
    try:
        async with httpx.AsyncClient(timeout=10.0, follow_redirects=True) as client:
            response = await client.get(url)
            response.raise_for_status()
            logger.info(f"Downloaded snapshot: {len(response.content)} bytes")
            return response.content
    except Exception as e:
        logger.error(f"Failed to download snapshot: {e}")
        raise


async def detect_deer(image_bytes: bytes) -> Dict[str, Any]:
    """Send image to ML detector"""
    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            files = {"file": ("snapshot.jpg", image_bytes, "image/jpeg")}
            response = await client.post(
                f"{CONFIG['ML_DETECTOR_URL']}/detect",
                files=files
            )
            response.raise_for_status()
            result = response.json()
            logger.info(f"ML detection: {result['num_detections']} objects, deer={result['deer_detected']}")
            return result
    except Exception as e:
        logger.error(f"ML detection failed: {e}")
        raise


async def activate_rainbird(zone: str, duration: int) -> bool:
    """Activate Rainbird irrigation zone"""
    if not CONFIG["RAINBIRD_IP"]:
        logger.warning("Rainbird IP not configured, skipping activation")
        return False
    
    if not CONFIG["ENABLE_IRRIGATION"]:
        logger.info("Irrigation activation disabled (dry-run mode)")
        return True
    
    try:
        # TODO: Implement actual Rainbird API call
        # This is a placeholder - we'll implement after reverse-engineering the API
        async with httpx.AsyncClient(timeout=10.0) as client:
            payload = {
                "zone": zone,
                "duration": duration
            }
            
            # Example endpoint (will be customized based on your Rainbird model)
            url = f"http://{CONFIG['RAINBIRD_IP']}/api/irrigation"
            
            logger.info(f"Activating Rainbird zone {zone} for {duration}s (simulated)")
            # response = await client.post(url, json=payload)
            # response.raise_for_status()
            
            # For now, just simulate success
            await asyncio.sleep(0.1)
            
            logger.info(f"✓ Irrigation zone {zone} activated for {duration}s")
            return True
            
    except Exception as e:
        logger.error(f"Failed to activate irrigation: {e}")
        return False


async def log_ring_event(camera_id: str, event_type: str, snapshot_available: bool = False,
                        snapshot_size: int = None, recording_url: str = None) -> Optional[int]:
    """Log Ring event to backend database for diagnostics"""
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.post(
                f"{CONFIG['BACKEND_API_URL']}/api/ring-events",
                json={
                    "camera_id": camera_id,
                    "event_type": event_type,
                    "timestamp": datetime.now().isoformat(),
                    "snapshot_available": snapshot_available,
                    "snapshot_size": snapshot_size,
                    "recording_url": recording_url
                }
            )
            if response.status_code == 200:
                result = response.json()
                return result.get("event_id")
    except Exception as e:
        logger.error(f"Failed to log Ring event: {e}")
    return None


async def log_to_backend(event_data: Dict[str, Any]):
    """Log detection event to backend database"""
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            await client.post(
                f"{CONFIG['BACKEND_API_URL']}/api/detections",
                json=event_data
            )
            logger.info("Logged event to backend")
    except Exception as e:
        logger.error(f"Failed to log to backend: {e}")


async def process_camera_event(camera_id: str, timestamp: str, snapshot_bytes: bytes = None, snapshot_url: str = None, source: str = "unknown", ring_event_id: int = None):
    """Process a camera motion event"""
    global last_activation_time
    
    try:
        logger.info(f"Processing camera event: {camera_id} at {timestamp} (source: {source})")
        
        # Check if within active hours
        if not is_active_hours():
            logger.info(f"Outside active hours ({CONFIG['ACTIVE_HOURS_START']}-{CONFIG['ACTIVE_HOURS_END']}), skipping")
            return
        
        # Get image bytes - either from cache or download
        if snapshot_bytes:
            # FAST PATH: Use cached snapshot from MQTT
            logger.info(f"✓ Using cached snapshot: {len(snapshot_bytes)} bytes")
            image_bytes = snapshot_bytes
            
            # Save for debugging
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            snapshot_path = Path(f"/app/snapshots/{ts}_{camera_id}.jpg")
            snapshot_path.parent.mkdir(parents=True, exist_ok=True)
            snapshot_path.write_bytes(image_bytes)
            
        elif snapshot_url:
            # SLOW PATH: Download and extract from video
            logger.info(f"Downloading from URL: {snapshot_url[:80]}...")
            media_bytes = await download_snapshot(snapshot_url)
            
            # Save media file temporarily
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            temp_path = Path(f"/app/snapshots/{ts}_{camera_id}_temp")
            temp_path.parent.mkdir(parents=True, exist_ok=True)
            temp_path.write_bytes(media_bytes)
            
            # Extract first frame if it's a video (MP4), otherwise use as-is
            snapshot_path = Path(f"/app/snapshots/{ts}_{camera_id}.jpg")
            if snapshot_url.lower().endswith('.mp4'):
                logger.info(f"Extracting frame from MP4 video...")
                import subprocess
                result = subprocess.run([
                    'ffmpeg', '-i', str(temp_path), 
                    '-vframes', '1', '-f', 'image2',
                    '-y', str(snapshot_path)
                ], capture_output=True, text=True)
                
                if result.returncode != 0:
                    logger.error(f"FFmpeg failed: {result.stderr}")
                    temp_path.unlink()
                    return
                
                temp_path.unlink()  # Clean up temp file
                logger.info(f"Extracted frame: {snapshot_path}")
            else:
                # Already an image, just rename
                temp_path.rename(snapshot_path)
                logger.info(f"Saved snapshot: {snapshot_path}")
            
            # Read the image for ML detection
            image_bytes = snapshot_path.read_bytes()
        else:
            logger.error("No snapshot_bytes or snapshot_url provided!")
            return
        
        # Run ML detection
        detection_result = await detect_deer(image_bytes)
        
        # Check if deer detected
        deer_detected = detection_result.get("deer_detected", False)
        confidence = 0.0
        
        if deer_detected and detection_result.get("detections"):
            # Get highest confidence deer detection
            deer_detections = [
                d for d in detection_result["detections"]
                if d["class"].lower() in ['deer', 'dog', 'horse', 'cow', 'sheep', 'bear']
            ]
            if deer_detections:
                confidence = max(d["confidence"] for d in deer_detections)
        
        logger.info(f"Detection result: deer={deer_detected}, confidence={confidence:.2f}")
        
        # Prepare event data
        event_data = {
            "timestamp": timestamp,
            "camera_id": camera_id,
            "deer_detected": deer_detected,
            "confidence": confidence,
            "snapshot_path": str(snapshot_path),
            "detections": detection_result.get("detections", []),
            "irrigation_activated": False
        }
        
        # Update Ring event with detection result
        if ring_event_id:
            try:
                async with httpx.AsyncClient(timeout=5.0) as client:
                    await client.patch(
                        f"{CONFIG['BACKEND_API_URL']}/api/ring-events/{ring_event_id}",
                        json={
                            "processed": True,
                            "deer_detected": deer_detected,
                            "confidence": confidence
                        }
                    )
            except Exception as e:
                logger.error(f"Failed to update Ring event: {e}")
        
        # If deer detected, check cooldown and activate irrigation
        if deer_detected:
            now = datetime.now()
            
            # Check cooldown
            if last_activation_time:
                elapsed = (now - last_activation_time).total_seconds()
                if elapsed < CONFIG["COOLDOWN_SECONDS"]:
                    logger.info(f"Cooldown active: {elapsed:.0f}s/{CONFIG['COOLDOWN_SECONDS']}s")
                    await log_to_backend(event_data)
                    return
            
            # Activate irrigation
            success = await activate_rainbird(
                CONFIG["RAINBIRD_ZONE"],
                CONFIG["RAINBIRD_DURATION_SECONDS"]
            )
            
            if success:
                last_activation_time = now
                event_data["irrigation_activated"] = True
                logger.info("✓✓✓ DEER DETERRENT ACTIVATED ✓✓✓")
        
        # Log to backend
        await log_to_backend(event_data)
        
    except Exception as e:
        logger.error(f"Error processing camera event: {e}", exc_info=True)


def on_mqtt_connect(client, userdata, flags, rc):
    """MQTT connection callback"""
    logger.info(f"MQTT on_connect callback fired with rc={rc}")
    if rc == 0:
        logger.info("✓ MQTT broker connection established in callback")
        # Subscribe to Ring camera motion events (Ring-MQTT v5.x format)
        topics = [
            ("ring/#", 0),  # Subscribe to ALL Ring topics for debugging
            ("ring/+/camera/+/event_select/attributes", 0),
            ("ring/+/camera/+/motion", 0),
            ("ring/+/camera/+/ding", 0),
        ]
        result = client.subscribe(topics)
        logger.info(f"✓ Subscribed to Ring motion topics with result: {result}")
        logger.info(f"  Topics: {[t[0] for t in topics]}")
    else:
        logger.error(f"MQTT connection failed with code {rc}")


def on_mqtt_message(client, userdata, msg):
    """MQTT message callback"""
    try:
        topic = msg.topic
        parts = topic.split('/')
        
        # Handle binary snapshot images - store them for instant access
        if len(parts) >= 6 and parts[0] == "ring" and parts[2] == "camera" and parts[4] == "snapshot" and parts[5] == "image":
            camera_id = parts[3]
            camera_snapshots[camera_id] = msg.payload
            logger.debug(f"Cached snapshot for camera {camera_id}: {len(msg.payload)} bytes")
            return
        
        # Try to decode text messages
        try:
            payload = msg.payload.decode()
        except UnicodeDecodeError:
            # Unknown binary message, skip
            return
        
        # Handle motion/state messages (INSTANT - 1-2 seconds after motion)
        if len(parts) >= 6 and parts[0] == "ring" and parts[2] == "camera" and parts[4] == "motion" and parts[5] == "state":
            camera_id = parts[3]
            
            if payload.upper() == "ON":
                logger.info(f"⚡ INSTANT motion detected on camera {camera_id}")
                
                # Log Ring event if within active hours (async task)
                ring_event_id = None
                if is_active_hours():
                    snapshot_available = camera_id in camera_snapshots
                    snapshot_size = len(camera_snapshots[camera_id]) if snapshot_available else None
                    # Schedule async logging task
                    asyncio.create_task(log_ring_event(
                        camera_id=camera_id,
                        event_type="motion",
                        snapshot_available=snapshot_available,
                        snapshot_size=snapshot_size
                    ))
                    logger.info("Scheduled Ring event logging task")
                
                # Check if we have a cached snapshot
                if camera_id in camera_snapshots:
                    logger.info(f"✓ Using cached snapshot ({len(camera_snapshots[camera_id])} bytes)")
                    
                    # Put event in queue with cached snapshot
                    event_queue.put({
                        "camera_id": camera_id,
                        "snapshot_bytes": camera_snapshots[camera_id],
                        "timestamp": datetime.now().isoformat(),
                        "source": "mqtt_snapshot",
                        "ring_event_id": None  # Will be set later
                    })
                else:
                    logger.warning(f"No cached snapshot for camera {camera_id}, will wait for recording URL")
            return
        
        # Handle event_select messages (SLOW - 30-60 seconds, used as fallback)
        if "event_select" in topic and len(parts) >= 6 and parts[4] == "event_select":
            logger.info(f"MQTT message: {topic} = {payload[:200]}")
            
            try:
                data = json.loads(payload)
                camera_id = parts[3]
                recording_url = data.get("recordingUrl")
                event_id = data.get("eventId")
                
                if recording_url:
                    logger.info(f"Recording URL available for camera {camera_id}, eventId={event_id}")
                    
                    # Log Ring event if within active hours (async task)
                    if is_active_hours():
                        asyncio.create_task(log_ring_event(
                            camera_id=camera_id,
                            event_type="recording",
                            snapshot_available=False,
                            recording_url=recording_url
                        ))
                        logger.info("Scheduled Ring recording event logging task")
                    
                    # Only use recording URL as fallback if we don't have a snapshot
                    if camera_id not in camera_snapshots:
                        logger.info("No cached snapshot, using recording URL (slower)")
                        event_queue.put({
                            "camera_id": camera_id,
                            "snapshot_url": recording_url,
                            "timestamp": datetime.now().isoformat(),
                            "source": "recording_url",
                            "ring_event_id": None  # Will be set later
                        })
                    else:
                        logger.info("Already processed with cached snapshot, skipping recording URL")
                    
            except json.JSONDecodeError:
                logger.warning(f"Failed to parse event_select JSON: {payload[:100]}")
            return
        
    except Exception as e:
        logger.error(f"Error processing MQTT message: {e}", exc_info=True)


def setup_mqtt():
    """Setup MQTT client"""
    global mqtt_client
    
    try:
        mqtt_client = mqtt.Client()
        mqtt_client.on_connect = on_mqtt_connect
        mqtt_client.on_message = on_mqtt_message
        
        if CONFIG["MQTT_USER"]:
            mqtt_client.username_pw_set(CONFIG["MQTT_USER"], CONFIG["MQTT_PASSWORD"])
        
        logger.info(f"Connecting to MQTT broker at {CONFIG['MQTT_HOST']}:{CONFIG['MQTT_PORT']}")
        mqtt_client.connect(CONFIG["MQTT_HOST"], CONFIG["MQTT_PORT"], 60)
        mqtt_client.loop_start()
        
        logger.info(f"MQTT client loop started (waiting for on_connect callback...)")
        
    except Exception as e:
        logger.error(f"Failed to setup MQTT: {e}")


async def process_event_queue():
    """Background task to process events from MQTT queue"""
    logger.info("Event queue processor started")
    
    while True:
        try:
            # Check queue for events (non-blocking)
            try:
                event = event_queue.get_nowait()
                logger.info(f"Processing queued event for camera {event['camera_id']}")
                
                # Process the event with either cached snapshot or URL
                await process_camera_event(
                    camera_id=event["camera_id"],
                    timestamp=event["timestamp"],
                    snapshot_bytes=event.get("snapshot_bytes"),
                    snapshot_url=event.get("snapshot_url"),
                    source=event.get("source", "unknown"),
                    ring_event_id=event.get("ring_event_id")
                )
                
                event_queue.task_done()
                
            except queue.Empty:
                # No events in queue, sleep briefly
                await asyncio.sleep(0.1)
                
        except Exception as e:
            logger.error(f"Error in event queue processor: {e}", exc_info=True)
            await asyncio.sleep(1)


@app.on_event("startup")
async def startup_event():
    """Initialize on startup"""
    logger.info("Starting Deer Deterrent Coordinator")
    logger.info(f"Configuration: {json.dumps(CONFIG, indent=2)}")
    setup_mqtt()
    
    # Start background task to process MQTT events
    asyncio.create_task(process_event_queue())


@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup on shutdown"""
    if mqtt_client:
        mqtt_client.loop_stop()
        mqtt_client.disconnect()
    logger.info("Coordinator shut down")


@app.get("/")
async def root():
    """Root endpoint"""
    return {
        "service": "Deer Deterrent Coordinator",
        "status": "running",
        "version": "1.0.0"
    }


@app.get("/health")
async def health_check():
    """Health check"""
    return {
        "status": "healthy",
        "mqtt_connected": mqtt_client and mqtt_client.is_connected() if mqtt_client else False,
        "last_activation": last_activation_time.isoformat() if last_activation_time else None,
        "active_hours": is_active_hours(),
        "config": {
            "rainbird_configured": bool(CONFIG["RAINBIRD_IP"]),
            "irrigation_enabled": CONFIG["ENABLE_IRRIGATION"],
            "cooldown_seconds": CONFIG["COOLDOWN_SECONDS"],
            "confidence_threshold": CONFIG["CONFIDENCE_THRESHOLD"]
        }
    }


@app.post("/webhook/test")
async def test_webhook(request: Request, background_tasks: BackgroundTasks):
    """Test endpoint for manual triggering"""
    try:
        payload = await request.json()
        
        camera_id = payload.get("camera_id", "test-camera")
        snapshot_url = payload.get("snapshot_url")
        timestamp = payload.get("timestamp", datetime.now().isoformat())
        
        if not snapshot_url:
            raise HTTPException(status_code=400, detail="Missing snapshot_url")
        
        background_tasks.add_task(process_camera_event, camera_id, snapshot_url, timestamp)
        
        return {"status": "accepted", "message": "Processing test event"}
        
    except Exception as e:
        logger.error(f"Test webhook error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/stats")
async def get_stats():
    """Get coordinator statistics"""
    snapshot_dir = Path("/app/snapshots")
    snapshot_count = len(list(snapshot_dir.glob("*.jpg"))) if snapshot_dir.exists() else 0
    
    cooldown_remaining = 0
    if last_activation_time:
        elapsed = (datetime.now() - last_activation_time).total_seconds()
        cooldown_remaining = max(0, CONFIG["COOLDOWN_SECONDS"] - elapsed)
    
    return {
        "total_snapshots": snapshot_count,
        "last_activation": last_activation_time.isoformat() if last_activation_time else None,
        "cooldown_remaining_seconds": int(cooldown_remaining),
        "active_hours": is_active_hours(),
        "mqtt_connected": mqtt_client.is_connected() if mqtt_client else False
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=5000,
        log_level=os.getenv("LOG_LEVEL", "info").lower()
    )
EOF

# Make the script executable
RUN chmod +x /app/coordinator_service.py

# Expose port
EXPOSE 5000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD curl -f http://localhost:5000/health || exit 1

# Run the service
CMD ["python", "/app/coordinator_service.py"]
