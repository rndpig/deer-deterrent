# =============================================================================
# Coordinator Dockerfile - Ring Webhook Handler & Irrigation Controller
# =============================================================================
# This container coordinates between Ring camera events, ML detection,
# and Rainbird irrigation activation
# =============================================================================

FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    curl \
    ffmpeg \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
RUN pip install --no-cache-dir \
    fastapi==0.115.0 \
    uvicorn[standard]==0.32.0 \
    httpx==0.27.2 \
    requests==2.31.0 \
    paho-mqtt==2.1.0 \
    python-multipart==0.0.17 \
    pyyaml==6.0.2 \
    python-dateutil==2.9.0

# Create directories
RUN mkdir -p /app/logs /app/snapshots /app/config

# Create the coordinator service
RUN cat > /app/coordinator_service.py << 'EOF'
#!/usr/bin/env python3
"""
Coordinator Service - Ring Camera → ML Detection → Irrigation Activation
Handles the complete flow from camera event to deterrent action
"""

import os
import logging
import json
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional, Dict, Any
import asyncio
import queue
import threading

from fastapi import FastAPI, Request, BackgroundTasks, HTTPException
from fastapi.responses import JSONResponse
import httpx
import requests
import paho.mqtt.client as mqtt

# Configure logging
logging.basicConfig(
    level=os.getenv("LOG_LEVEL", "INFO"),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/app/logs/coordinator.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title="Deer Deterrent Coordinator",
    description="Coordinates Ring cameras, ML detection, and irrigation activation",
    version="1.0.0"
)

# Configuration
CONFIG = {
    "ML_DETECTOR_URL": os.getenv("ML_DETECTOR_URL", "http://ml-detector:8001"),
    "BACKEND_API_URL": os.getenv("BACKEND_API_URL", "http://backend:8000"),
    "MQTT_HOST": os.getenv("MQTT_HOST", "mosquitto"),
    "MQTT_PORT": int(os.getenv("MQTT_PORT", "1883")),
    "MQTT_USER": os.getenv("MQTT_USER", ""),
    "MQTT_PASSWORD": os.getenv("MQTT_PASSWORD", ""),
    "RAINBIRD_IP": os.getenv("RAINBIRD_IP", ""),
    "RAINBIRD_PASSWORD": os.getenv("RAINBIRD_PASSWORD", ""),
    "RAINBIRD_ZONE": os.getenv("RAINBIRD_ZONE", "1"),
    "RAINBIRD_DURATION_SECONDS": int(os.getenv("RAINBIRD_DURATION_SECONDS", "30")),
    "CONFIDENCE_THRESHOLD": float(os.getenv("CONFIDENCE_THRESHOLD", "0.30")),
    "COOLDOWN_SECONDS": int(os.getenv("COOLDOWN_SECONDS", "300")),
    "ENABLE_IRRIGATION": os.getenv("ENABLE_IRRIGATION", "true").lower() == "true",
    "ACTIVE_HOURS_START": int(os.getenv("ACTIVE_HOURS_START", "0")),
    "ACTIVE_HOURS_END": int(os.getenv("ACTIVE_HOURS_END", "24")),
    "ENABLED_CAMERAS": ["10cea9e4511f"],  # Default to Side camera only, updated from backend settings
    # Periodic snapshot polling configuration
    "ENABLE_PERIODIC_SNAPSHOTS": os.getenv("ENABLE_PERIODIC_SNAPSHOTS", "false").lower() == "true",
    "PERIODIC_SNAPSHOT_INTERVAL": int(os.getenv("PERIODIC_SNAPSHOT_INTERVAL", "60")),
    "RING_LOCATION_ID": os.getenv("RING_LOCATION_ID", ""),  # Needed for MQTT topics
}

# State tracking
last_activation_time: Optional[datetime] = None
mqtt_client: Optional[mqtt.Client] = None
event_queue: queue.PriorityQueue = queue.PriorityQueue()  # Priority queue: motion > periodic
camera_snapshots: Dict[str, bytes] = {}  # Store latest snapshot for each camera
last_periodic_snapshot_time: Dict[str, datetime] = {}  # Track last periodic snapshot per camera


async def fetch_settings_from_backend():
    """Fetch settings from backend API"""
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(f"{CONFIG['BACKEND_API_URL']}/api/settings", timeout=5.0)
            if response.status_code == 200:
                settings = response.json()
                # Update confidence threshold if changed
                new_threshold = settings.get('confidence_threshold')
                if new_threshold is not None:
                    old_threshold = CONFIG["CONFIDENCE_THRESHOLD"]
                    CONFIG["CONFIDENCE_THRESHOLD"] = float(new_threshold)
                    if old_threshold != CONFIG["CONFIDENCE_THRESHOLD"]:
                        logger.info(f"Updated confidence threshold from {old_threshold} to {CONFIG['CONFIDENCE_THRESHOLD']}")
                
                # Update enabled cameras if changed
                new_cameras = settings.get('enabled_cameras')
                if new_cameras is not None:
                    old_cameras = CONFIG.get("ENABLED_CAMERAS", [])
                    CONFIG["ENABLED_CAMERAS"] = new_cameras
                    if old_cameras != CONFIG["ENABLED_CAMERAS"]:
                        logger.info(f"Updated enabled cameras from {old_cameras} to {CONFIG['ENABLED_CAMERAS']}")
                return True
    except httpx.TimeoutException:
        logger.warning("Timeout fetching settings from backend")
    except Exception as e:
        logger.warning(f"Could not fetch settings from backend: {e}")
    return False


async def settings_refresh_loop():
    """Background task to periodically refresh settings from backend"""
    logger.info("Starting settings refresh loop")
    # Initial fetch
    await fetch_settings_from_backend()
    
    # Refresh every 30 seconds
    while True:
        await asyncio.sleep(30)
        await fetch_settings_from_backend()


def is_active_hours() -> bool:
    """Check if current time is within active hours"""
    current_hour = datetime.now().hour
    start = CONFIG["ACTIVE_HOURS_START"]
    end = CONFIG["ACTIVE_HOURS_END"]
    
    if start <= end:
        return start <= current_hour < end
    else:  # Wraps midnight
        return current_hour >= start or current_hour < end


async def request_high_res_snapshot(camera_id: str) -> Optional[bytes]:
    """Request a fresh high-resolution snapshot from Ring via ring-mqtt"""
    try:
        # Ring-MQTT exposes an API to request fresh snapshots
        # Publish a command to request snapshot refresh
        if mqtt_client and mqtt_client.is_connected():
            # Topic format: ring/{location_id}/camera/{camera_id}/snapshot/refresh
            # The location_id is in the MQTT topic structure we've seen
            location_id = "dp1hu9-2i94c-0"  # From the MQTT topics we observed
            refresh_topic = f"ring/{location_id}/camera/{camera_id}/snapshot/refresh"
            
            logger.info(f"Requesting high-res snapshot for camera {camera_id}...")
            mqtt_client.publish(refresh_topic, "ON")
            
            # Wait up to 3 seconds for the new snapshot to arrive
            for i in range(30):  # 30 * 0.1s = 3 seconds
                await asyncio.sleep(0.1)
                if camera_id in camera_snapshots:
                    snapshot_bytes = camera_snapshots[camera_id]
                    # Check if it's reasonably sized (>50KB suggests high-res)
                    if len(snapshot_bytes) > 50000:
                        logger.info(f"✓ Received high-res snapshot: {len(snapshot_bytes)} bytes")
                        return snapshot_bytes
            
            # If we got here, we either got a low-res or no snapshot
            if camera_id in camera_snapshots:
                snapshot_bytes = camera_snapshots[camera_id]
                logger.warning(f"Snapshot may be low-res: {len(snapshot_bytes)} bytes")
                return snapshot_bytes
            else:
                logger.warning(f"No snapshot received after refresh request")
                return None
    except Exception as e:
        logger.error(f"Failed to request high-res snapshot: {e}")
        return None


async def download_snapshot(url: str) -> bytes:
    """Download image from URL"""
    try:
        async with httpx.AsyncClient(timeout=10.0, follow_redirects=True) as client:
            response = await client.get(url)
            response.raise_for_status()
            logger.info(f"Downloaded snapshot: {len(response.content)} bytes")
            return response.content
    except Exception as e:
        logger.error(f"Failed to download snapshot: {e}")
        raise


async def detect_deer(image_bytes: bytes) -> Dict[str, Any]:
    """Send image to ML detector"""
    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            files = {"file": ("snapshot.jpg", image_bytes, "image/jpeg")}
            response = await client.post(
                f"{CONFIG['ML_DETECTOR_URL']}/detect",
                files=files
            )
            response.raise_for_status()
            result = response.json()
            logger.info(f"ML detection: {result['num_detections']} objects, deer={result['deer_detected']}")
            return result
    except Exception as e:
        logger.error(f"ML detection failed: {e}")
        raise


async def activate_rainbird(zone: str, duration: int) -> bool:
    """Activate Rainbird irrigation zone"""
    if not CONFIG["RAINBIRD_IP"]:
        logger.warning("Rainbird IP not configured, skipping activation")
        return False
    
    if not CONFIG["ENABLE_IRRIGATION"]:
        logger.info("Irrigation activation disabled (dry-run mode)")
        return True
    
    try:
        # TODO: Implement actual Rainbird API call
        # This is a placeholder - we'll implement after reverse-engineering the API
        async with httpx.AsyncClient(timeout=10.0) as client:
            payload = {
                "zone": zone,
                "duration": duration
            }
            
            # Example endpoint (will be customized based on your Rainbird model)
            url = f"http://{CONFIG['RAINBIRD_IP']}/api/irrigation"
            
            logger.info(f"Activating Rainbird zone {zone} for {duration}s (simulated)")
            # response = await client.post(url, json=payload)
            # response.raise_for_status()
            
            # For now, just simulate success
            await asyncio.sleep(0.1)
            
            logger.info(f"✓ Irrigation zone {zone} activated for {duration}s")
            return True
            
    except Exception as e:
        logger.error(f"Failed to activate irrigation: {e}")
        return False


def log_ring_event(camera_id: str, event_type: str, snapshot_available: bool = False,
                   snapshot_size: int = None, snapshot_path: str = None, recording_url: str = None) -> Optional[int]:
    """Log Ring event to backend database for diagnostics (synchronous for MQTT thread)"""
    try:
        response = requests.post(
            f"{CONFIG['BACKEND_API_URL']}/api/ring-events",
            json={
                "camera_id": camera_id,
                "event_type": event_type,
                "timestamp": datetime.now().isoformat(),
                "snapshot_available": snapshot_available,
                "snapshot_size": snapshot_size,
                "snapshot_path": snapshot_path,
                "recording_url": recording_url
            },
            timeout=5.0
        )
        if response.status_code == 200:
            result = response.json()
            return result.get("event_id")
    except Exception as e:
        logger.error(f"Failed to log Ring event: {e}")
    return None


async def log_to_backend(event_data: Dict[str, Any]):
    """Log detection event to backend database"""
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            await client.post(
                f"{CONFIG['BACKEND_API_URL']}/api/detections",
                json=event_data
            )
            logger.info("Logged event to backend")
    except Exception as e:
        logger.error(f"Failed to log to backend: {e}")


async def process_camera_event(camera_id: str, timestamp: str, snapshot_bytes: bytes = None, snapshot_url: str = None, request_snapshot: bool = False, source: str = "unknown", ring_event_id: int = None):
    """Process a camera motion event"""
    global last_activation_time
    
    try:
        logger.info(f"Processing camera event: {camera_id} at {timestamp} (source: {source})")
        
        # Check if camera is enabled for detection
        enabled_cameras = CONFIG.get("ENABLED_CAMERAS", [])
        if enabled_cameras and camera_id not in enabled_cameras:
            logger.info(f"Camera {camera_id} not in enabled cameras list {enabled_cameras}, skipping detection")
            return
        
        # Check if within active hours
        if not is_active_hours():
            logger.info(f"Outside active hours ({CONFIG['ACTIVE_HOURS_START']}-{CONFIG['ACTIVE_HOURS_END']}), skipping")
            return
        
        # Get image bytes - prioritize high-res snapshot request
        if request_snapshot:
            # Request a fresh high-resolution snapshot
            logger.info(f"Requesting fresh high-resolution snapshot from Ring...")
            image_bytes = await request_high_res_snapshot(camera_id)
            
            if not image_bytes:
                logger.error(f"Failed to get high-res snapshot for camera {camera_id}")
                return
            
            # Save for debugging
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            snapshot_path = Path(f"/app/snapshots/{ts}_{camera_id}_highres.jpg")
            snapshot_path.parent.mkdir(parents=True, exist_ok=True)
            snapshot_path.write_bytes(image_bytes)
            logger.info(f"Saved high-res snapshot: {snapshot_path} ({len(image_bytes)} bytes)")
            
        elif snapshot_bytes:
            # FAST PATH: Use cached snapshot from MQTT
            logger.info(f"✓ Using cached snapshot: {len(snapshot_bytes)} bytes")
            image_bytes = snapshot_bytes
            
            # Save for debugging
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            snapshot_path = Path(f"/app/snapshots/{ts}_{camera_id}.jpg")
            snapshot_path.parent.mkdir(parents=True, exist_ok=True)
            snapshot_path.write_bytes(image_bytes)
            
        elif snapshot_url:
            # SLOW PATH: Download and extract from video
            logger.info(f"Downloading from URL: {snapshot_url[:80]}...")
            media_bytes = await download_snapshot(snapshot_url)
            
            # Save media file temporarily
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            temp_path = Path(f"/app/snapshots/{ts}_{camera_id}_temp")
            temp_path.parent.mkdir(parents=True, exist_ok=True)
            temp_path.write_bytes(media_bytes)
            
            # Extract first frame if it's a video (MP4), otherwise use as-is
            snapshot_path = Path(f"/app/snapshots/{ts}_{camera_id}.jpg")
            if snapshot_url.lower().endswith('.mp4'):
                logger.info(f"Extracting frame from MP4 video...")
                import subprocess
                result = subprocess.run([
                    'ffmpeg', '-i', str(temp_path), 
                    '-vframes', '1', '-f', 'image2',
                    '-y', str(snapshot_path)
                ], capture_output=True, text=True)
                
                if result.returncode != 0:
                    logger.error(f"FFmpeg failed: {result.stderr}")
                    temp_path.unlink()
                    return
                
                temp_path.unlink()  # Clean up temp file
                logger.info(f"Extracted frame: {snapshot_path}")
            else:
                # Already an image, just rename
                temp_path.rename(snapshot_path)
                logger.info(f"Saved snapshot: {snapshot_path}")
            
            # Read the image for ML detection
            image_bytes = snapshot_path.read_bytes()
        else:
            logger.error("No snapshot_bytes or snapshot_url provided!")
            return
        
        # Run ML detection
        detection_result = await detect_deer(image_bytes)
        
        # Check if deer detected
        deer_detected = detection_result.get("deer_detected", False)
        confidence = 0.0
        
        if deer_detected and detection_result.get("detections"):
            # Get highest confidence deer detection (only actual deer class)
            deer_detections = [
                d for d in detection_result["detections"]
                if d["class"].lower() == 'deer'
            ]
            if deer_detections:
                confidence = max(d["confidence"] for d in deer_detections)
        
        logger.info(f"Detection result: deer={deer_detected}, confidence={confidence:.2f}")
        
        # Prepare event data
        event_data = {
            "timestamp": timestamp,
            "camera_id": camera_id,
            "deer_detected": deer_detected,
            "confidence": confidence,
            "snapshot_path": str(snapshot_path),
            "detections": detection_result.get("detections", []),
            "irrigation_activated": False
        }
        
        # Update Ring event with detection result
        if ring_event_id:
            try:
                async with httpx.AsyncClient(timeout=5.0) as client:
                    await client.patch(
                        f"{CONFIG['BACKEND_API_URL']}/api/ring-events/{ring_event_id}",
                        json={
                            "processed": True,
                            "deer_detected": deer_detected,
                            "confidence": confidence
                        }
                    )
            except Exception as e:
                logger.error(f"Failed to update Ring event: {e}")
        
        # If deer detected, check cooldown and activate irrigation
        if deer_detected:
            now = datetime.now()
            
            # Check cooldown
            if last_activation_time:
                elapsed = (now - last_activation_time).total_seconds()
                if elapsed < CONFIG["COOLDOWN_SECONDS"]:
                    logger.info(f"Cooldown active: {elapsed:.0f}s/{CONFIG['COOLDOWN_SECONDS']}s")
                    await log_to_backend(event_data)
                    return
            
            # Activate irrigation
            success = await activate_rainbird(
                CONFIG["RAINBIRD_ZONE"],
                CONFIG["RAINBIRD_DURATION_SECONDS"]
            )
            
            if success:
                last_activation_time = now
                event_data["irrigation_activated"] = True
                logger.info("✓✓✓ DEER DETERRENT ACTIVATED ✓✓✓")
        
        # Log to backend
        await log_to_backend(event_data)
        
    except Exception as e:
        logger.error(f"Error processing camera event: {e}", exc_info=True)


def on_mqtt_connect(client, userdata, flags, rc):
    """MQTT connection callback"""
    logger.info(f"MQTT on_connect callback fired with rc={rc}")
    if rc == 0:
        logger.info("✓ MQTT broker connection established in callback")
        # Subscribe to Ring camera motion events (Ring-MQTT v5.x format)
        topics = [
            ("ring/#", 0),  # Subscribe to ALL Ring topics for debugging
            ("ring/+/camera/+/event_select/attributes", 0),
            ("ring/+/camera/+/motion", 0),
            ("ring/+/camera/+/ding", 0),
        ]
        result = client.subscribe(topics)
        logger.info(f"✓ Subscribed to Ring motion topics with result: {result}")
        logger.info(f"  Topics: {[t[0] for t in topics]}")
    else:
        logger.error(f"MQTT connection failed with code {rc}")


def on_mqtt_message(client, userdata, msg):
    """MQTT message callback"""
    try:
        topic = msg.topic
        parts = topic.split('/')
        
        # Extract location_id from topic if not yet configured
        if not CONFIG["RING_LOCATION_ID"] and len(parts) >= 2 and parts[0] == "ring":
            CONFIG["RING_LOCATION_ID"] = parts[1]
            logger.info(f"Detected Ring location ID: {CONFIG['RING_LOCATION_ID']}")
        
        # Handle binary snapshot images - store them for instant access
        if len(parts) >= 6 and parts[0] == "ring" and parts[2] == "camera" and parts[4] == "snapshot" and parts[5] == "image":
            camera_id = parts[3]
            camera_snapshots[camera_id] = msg.payload
            logger.debug(f"Cached snapshot for camera {camera_id}: {len(msg.payload)} bytes")
            return
        
        # Try to decode text messages
        try:
            payload = msg.payload.decode()
        except UnicodeDecodeError:
            # Unknown binary message, skip
            return
        
        # Handle motion/state messages (INSTANT - 1-2 seconds after motion)
        if len(parts) >= 6 and parts[0] == "ring" and parts[2] == "camera" and parts[4] == "motion" and parts[5] == "state":
            camera_id = parts[3]
            
            if payload.upper() == "ON":
                logger.info(f"⚡ INSTANT motion detected on camera {camera_id}")
                
                # Log Ring event if within active hours (synchronous call)
                ring_event_id = None
                snapshot_path = None
                if is_active_hours():
                    snapshot_available = camera_id in camera_snapshots
                    snapshot_size = len(camera_snapshots[camera_id]) if snapshot_available else None
                    
                    # Save snapshot to disk for later analysis/testing
                    if snapshot_available:
                        try:
                            from pathlib import Path
                            snapshot_dir = Path("/app/snapshots")
                            snapshot_dir.mkdir(parents=True, exist_ok=True)
                            
                            timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
                            snapshot_filename = f"event_{timestamp_str}_{camera_id}_snapshot.jpg"
                            snapshot_path_obj = snapshot_dir / snapshot_filename
                            snapshot_path_obj.write_bytes(camera_snapshots[camera_id])
                            snapshot_path = f"snapshots/{snapshot_filename}"
                            
                            logger.info(f"✓ Saved snapshot to {snapshot_path}")
                        except Exception as e:
                            logger.error(f"Failed to save snapshot: {e}")
                            snapshot_path = None
                    
                    # Call synchronous logging function (runs in MQTT thread)
                    ring_event_id = log_ring_event(
                        camera_id=camera_id,
                        event_type="motion",
                        snapshot_available=snapshot_available,
                        snapshot_size=snapshot_size,
                        snapshot_path=snapshot_path
                    )
                    if ring_event_id:
                        logger.info(f"Logged Ring event #{ring_event_id}")
                
                # Use instant snapshot for real-time detection (low-res but fast)
                if camera_id in camera_snapshots:
                    logger.info(f"✓ Using instant snapshot for real-time detection")
                    event_queue.put((0, {  # Priority 0 = highest (motion events)
                        "camera_id": camera_id,
                        "snapshot_bytes": camera_snapshots[camera_id],
                        "timestamp": datetime.now().isoformat(),
                        "source": "instant_snapshot",
                        "ring_event_id": ring_event_id
                    }))
                else:
                    logger.warning(f"No cached snapshot available for {camera_id}")
            return
        
        # Handle event_select messages (SLOW - 30-60 seconds, skip for now since we use instant snapshots)
        if "event_select" in topic and len(parts) >= 6 and parts[4] == "event_select":
            # Skip processing recording URLs - we already processed instant snapshot
            logger.debug(f"Skipping event_select (already processed instant snapshot): {topic}")
            return
        
    except Exception as e:
        logger.error(f"Error processing MQTT message: {e}", exc_info=True)


def setup_mqtt():
    """Setup MQTT client"""
    global mqtt_client
    
    try:
        mqtt_client = mqtt.Client()
        mqtt_client.on_connect = on_mqtt_connect
        mqtt_client.on_message = on_mqtt_message
        
        if CONFIG["MQTT_USER"]:
            mqtt_client.username_pw_set(CONFIG["MQTT_USER"], CONFIG["MQTT_PASSWORD"])
        
        logger.info(f"Connecting to MQTT broker at {CONFIG['MQTT_HOST']}:{CONFIG['MQTT_PORT']}")
        mqtt_client.connect(CONFIG["MQTT_HOST"], CONFIG["MQTT_PORT"], 60)
        mqtt_client.loop_start()
        
        logger.info(f"MQTT client loop started (waiting for on_connect callback...)")
        
    except Exception as e:
        logger.error(f"Failed to setup MQTT: {e}")


async def process_event_queue():
    """Background task to process events from MQTT queue"""
    logger.info("Event queue processor started")
    
    while True:
        try:
            # Check queue for events (non-blocking)
            try:
                priority, event = event_queue.get_nowait()  # Get tuple (priority, event)
                source = event.get("source", "unknown")
                logger.info(f"Processing queued event for camera {event['camera_id']} (priority={priority}, source={source})")
                
                # Process the event with either cached snapshot or URL
                await process_camera_event(
                    camera_id=event["camera_id"],
                    timestamp=event["timestamp"],
                    snapshot_bytes=event.get("snapshot_bytes"),
                    snapshot_url=event.get("snapshot_url"),
                    request_snapshot=event.get("request_snapshot", False),
                    source=event.get("source", "unknown"),
                    ring_event_id=event.get("ring_event_id")
                )
                
                event_queue.task_done()
                
            except queue.Empty:
                # No events in queue, sleep briefly
                await asyncio.sleep(0.1)
                
        except Exception as e:
            logger.error(f"Error in event queue processor: {e}", exc_info=True)
            await asyncio.sleep(1)


async def periodic_snapshot_poller():
    """Request snapshots from configured cameras at regular intervals"""
    logger.info("Periodic snapshot poller started")
    
    if not CONFIG["ENABLE_PERIODIC_SNAPSHOTS"]:
        logger.info("Periodic snapshots disabled, poller exiting")
        return
    
    if not CONFIG["RING_LOCATION_ID"]:
        logger.error("RING_LOCATION_ID not configured, periodic snapshots disabled")
        return
    
    logger.info(f"Periodic snapshots enabled: cameras={CONFIG['ENABLED_CAMERAS']}, interval={CONFIG['PERIODIC_SNAPSHOT_INTERVAL']}s")
    
    # Subscribe to snapshot response topics
    for camera_id in CONFIG["ENABLED_CAMERAS"]:
        topic = f"ring/{CONFIG['RING_LOCATION_ID']}/camera/{camera_id}/snapshot/image"
        mqtt_client.subscribe(topic)
        logger.info(f"Subscribed to periodic snapshots: {topic}")
    
    while True:
        try:
            await asyncio.sleep(CONFIG["PERIODIC_SNAPSHOT_INTERVAL"])
            
            if not is_active_hours():
                logger.debug("Outside active hours, skipping periodic snapshots")
                continue
            
            for camera_id in CONFIG["ENABLED_CAMERAS"]:
                # Request snapshot via MQTT
                topic = f"ring/{CONFIG['RING_LOCATION_ID']}/camera/{camera_id}/snapshot/command"
                mqtt_client.publish(topic, "")
                logger.info(f"Requested periodic snapshot from camera {camera_id}")
                
                # Wait a bit for snapshot to arrive, then queue for processing
                await asyncio.sleep(2)  # Give Ring-MQTT time to publish snapshot
                
                if camera_id in camera_snapshots:
                    # Log Ring event (synchronous)
                    snapshot_size = len(camera_snapshots[camera_id])
                    
                    # Save snapshot to disk
                    timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
                    snapshot_filename = f"periodic_{timestamp_str}_{camera_id}.jpg"
                    snapshot_path_obj = Path(f"/app/data/snapshots/{snapshot_filename}")
                    snapshot_path_obj.parent.mkdir(parents=True, exist_ok=True)
                    snapshot_path_obj.write_bytes(camera_snapshots[camera_id])
                    snapshot_path = f"data/snapshots/{snapshot_filename}"
                    
                    logger.info(f"✓ Saved periodic snapshot to {snapshot_path}")
                    
                    ring_event_id = log_ring_event(
                        camera_id=camera_id,
                        event_type="periodic_snapshot",
                        snapshot_available=True,
                        snapshot_size=snapshot_size,
                        snapshot_path=snapshot_path
                    )
                    
                    if ring_event_id:
                        logger.info(f"Logged periodic snapshot event #{ring_event_id}")
                    
                    # Queue for ML detection (lower priority than motion events)
                    event_queue.put((1, {  # Priority 1 = lower (periodic snapshots)
                        "camera_id": camera_id,
                        "snapshot_bytes": camera_snapshots[camera_id],
                        "timestamp": datetime.now().isoformat(),
                        "source": "periodic_snapshot",
                        "ring_event_id": ring_event_id
                    }))
                    
                    last_periodic_snapshot_time[camera_id] = datetime.now()
                else:
                    logger.warning(f"No snapshot received for periodic request from {camera_id}")
        
        except Exception as e:
            logger.error(f"Error in periodic snapshot poller: {e}", exc_info=True)
            await asyncio.sleep(60)


async def cleanup_no_deer_snapshots():
    """Delete snapshots older than 48h with no deer detection"""
    logger.info("Snapshot cleanup task started")
    
    while True:
        try:
            # Run every hour
            await asyncio.sleep(3600)
            
            # Calculate cutoff time (48 hours ago)
            cutoff = datetime.now() - timedelta(hours=48)
            
            # Call backend API to delete old no-deer periodic snapshots
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.post(
                    f"{CONFIG['BACKEND_API_URL']}/api/cleanup-old-snapshots",
                    json={
                        "event_type": "periodic_snapshot",
                        "deer_detected": False,
                        "older_than": cutoff.isoformat()
                    }
                )
                
                if response.status_code == 200:
                    result = response.json()
                    deleted_count = result.get("deleted", 0)
                    if deleted_count > 0:
                        logger.info(f"Cleaned up {deleted_count} old no-deer periodic snapshots")
                else:
                    logger.warning(f"Cleanup request failed: HTTP {response.status_code}")
        
        except Exception as e:
            logger.error(f"Error in snapshot cleanup task: {e}", exc_info=True)


@app.on_event("startup")
async def startup_event():
    """Initialize on startup"""
    logger.info("Starting Deer Deterrent Coordinator")
    logger.info(f"Configuration: {json.dumps(CONFIG, indent=2)}")
    setup_mqtt()
    
    # Start background task to fetch settings from backend
    asyncio.create_task(settings_refresh_loop())
    
    # Start background task to process MQTT events
    asyncio.create_task(process_event_queue())
    
    # Start periodic snapshot polling if enabled
    if CONFIG["ENABLE_PERIODIC_SNAPSHOTS"]:
        asyncio.create_task(periodic_snapshot_poller())
        asyncio.create_task(cleanup_no_deer_snapshots())
        logger.info("Started periodic snapshot polling and cleanup tasks")


@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup on shutdown"""
    if mqtt_client:
        mqtt_client.loop_stop()
        mqtt_client.disconnect()
    logger.info("Coordinator shut down")


@app.get("/")
async def root():
    """Root endpoint"""
    return {
        "service": "Deer Deterrent Coordinator",
        "status": "running",
        "version": "1.0.0"
    }


@app.get("/health")
async def health_check():
    """Health check"""
    return {
        "status": "healthy",
        "mqtt_connected": mqtt_client and mqtt_client.is_connected() if mqtt_client else False,
        "last_activation": last_activation_time.isoformat() if last_activation_time else None,
        "active_hours": is_active_hours(),
        "config": {
            "rainbird_configured": bool(CONFIG["RAINBIRD_IP"]),
            "irrigation_enabled": CONFIG["ENABLE_IRRIGATION"],
            "cooldown_seconds": CONFIG["COOLDOWN_SECONDS"],
            "confidence_threshold": CONFIG["CONFIDENCE_THRESHOLD"]
        }
    }


@app.post("/webhook/test")
async def test_webhook(request: Request, background_tasks: BackgroundTasks):
    """Test endpoint for manual triggering"""
    try:
        payload = await request.json()
        
        camera_id = payload.get("camera_id", "test-camera")
        snapshot_url = payload.get("snapshot_url")
        timestamp = payload.get("timestamp", datetime.now().isoformat())
        
        if not snapshot_url:
            raise HTTPException(status_code=400, detail="Missing snapshot_url")
        
        background_tasks.add_task(process_camera_event, camera_id, snapshot_url, timestamp)
        
        return {"status": "accepted", "message": "Processing test event"}
        
    except Exception as e:
        logger.error(f"Test webhook error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/stats")
async def get_stats():
    """Get coordinator statistics"""
    snapshot_dir = Path("/app/snapshots")
    snapshot_count = len(list(snapshot_dir.glob("*.jpg"))) if snapshot_dir.exists() else 0
    
    cooldown_remaining = 0
    if last_activation_time:
        elapsed = (datetime.now() - last_activation_time).total_seconds()
        cooldown_remaining = max(0, CONFIG["COOLDOWN_SECONDS"] - elapsed)
    
    return {
        "total_snapshots": snapshot_count,
        "last_activation": last_activation_time.isoformat() if last_activation_time else None,
        "cooldown_remaining_seconds": int(cooldown_remaining),
        "active_hours": is_active_hours(),
        "mqtt_connected": mqtt_client.is_connected() if mqtt_client else False
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=5000,
        log_level=os.getenv("LOG_LEVEL", "info").lower()
    )
EOF

# Make the script executable
RUN chmod +x /app/coordinator_service.py

# Expose port
EXPOSE 5000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD curl -f http://localhost:5000/health || exit 1

# Run the service
CMD ["python", "/app/coordinator_service.py"]
